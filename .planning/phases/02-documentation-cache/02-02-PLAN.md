---
phase: 02-documentation-cache
plan: 02
type: execute
wave: 2
depends_on: [02-01]
files_modified:
  - src/lib/cache/manager.ts
  - src/lib/cache/manager.test.ts
  - src/cli.ts
autonomous: true

must_haves:
  truths:
    - "Cache manager checks if cache exists and is fresh (<24 hours old)"
    - "Cache manager triggers download only when cache missing or stale"
    - "Cache manager uses stale cache when download fails (graceful degradation)"
    - "CLI orchestrates cache check before transpilation"
    - "Installer continues to transpilation even if cache fails"
  artifacts:
    - path: "src/lib/cache/manager.ts"
      provides: "Cache orchestration with freshness checks"
      exports: ["ensureOpenCodeDocsCache"]
      min_lines: 70
    - path: "src/lib/cache/manager.test.ts"
      provides: "Cache manager test coverage"
      contains: "describe('ensureOpenCodeDocsCache'"
      min_lines: 60
    - path: "src/cli.ts"
      provides: "CLI integration with cache step"
      contains: "ensureOpenCodeDocsCache"
      min_lines: 100
  key_links:
    - from: "src/lib/cache/manager.ts"
      to: "src/lib/cache/downloader.ts"
      via: "imports downloadOpenCodeDocs"
      pattern: "import.*downloadOpenCodeDocs"
    - from: "src/lib/cache/manager.ts"
      to: "fs (existsSync, readFile)"
      via: "checks metadata.json existence and age"
      pattern: "existsSync.*metadata\\.json"
    - from: "src/cli.ts"
      to: "src/lib/cache/manager.ts"
      via: "calls ensureOpenCodeDocsCache after detection"
      pattern: "ensureOpenCodeDocsCache"
---

<objective>
Create cache manager with freshness logic and integrate into CLI flow.

Purpose: Orchestrate the cache lifecycle with 24-hour TTL checking. Only download when necessary, gracefully degrade to stale cache on network failures, and integrate seamlessly into the installer flow without blocking transpilation.

Output: Cache manager that intelligently decides when to download vs use existing cache, and CLI integration that caches OpenCode docs before transpilation while handling failures gracefully.
</objective>

<execution_context>
@C:\Users\Terence\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\Terence\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan outputs
@.planning/phases/02-documentation-cache/02-01-SUMMARY.md

# Existing code to understand CLI flow
@src/cli.ts
@src/lib/detector.ts

# New cache infrastructure from 02-01
@src/lib/cache/paths.ts
@src/lib/cache/types.ts
@src/lib/cache/downloader.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Cache Manager with Freshness Logic</name>
  <files>
    src/lib/cache/manager.ts
    src/lib/cache/manager.test.ts
  </files>
  <action>
Create cache manager that implements 24-hour TTL checking and graceful degradation.

**src/lib/cache/manager.ts:**

Export `ensureOpenCodeDocsCache()` async function that returns `{ cached: boolean, stale: boolean, error?: string }`:

**Algorithm:**
1. **Check cache existence:**
   - Look for ~/.gsdo/cache/docs-opencode/metadata.json using existsSync
   - If missing: Go to step 4 (download needed)

2. **Check cache freshness:**
   - Read metadata.json and parse downloadedAt timestamp
   - Calculate age: `Date.now() - new Date(downloadedAt).getTime()`
   - If age < 24 hours (86400000ms): Return `{ cached: true, stale: false }` (cache is fresh, skip download)
   - If age >= 24 hours: Go to step 4 (cache is stale, refresh needed)

3. **Handle metadata read errors:**
   - If metadata.json exists but can't be read/parsed: Treat as stale, go to step 4
   - Log warning but don't fail

4. **Attempt download:**
   - Call `downloadOpenCodeDocs()` from downloader.ts
   - If success: Return `{ cached: true, stale: false }`
   - If failure AND old cache exists: Return `{ cached: true, stale: true, error: downloadResult.error }` (graceful degradation)
   - If failure AND no cache: Return `{ cached: false, stale: false, error: downloadResult.error }` (first-run failure)

**Error Handling Philosophy:**
- Never throw exceptions - always return result object
- Prefer stale cache over no cache
- Log warnings but don't block installer flow

**src/lib/cache/manager.test.ts:**
Test scenarios:
1. Fresh cache (<24hrs): Returns cached: true, stale: false, skips download
2. Stale cache (>24hrs): Triggers download, returns updated cache
3. Missing cache: Triggers download
4. Download failure with stale cache: Returns cached: true, stale: true (graceful degradation)
5. Download failure with no cache: Returns cached: false, error message
6. Corrupted metadata.json: Treats as stale, attempts download
7. Timestamp parsing edge cases: Invalid dates, future dates

Use Vitest mocking to control time (Date.now) and file system state.

**Why 24 hours:**
- Balances freshness with network overhead
- OpenCode docs don't change frequently
- Allows offline work after initial download
  </action>
  <verify>
Run `npm test` - all cache manager tests pass (7 scenarios).
Run `npm run build` - TypeScript compilation succeeds.
Check manager exports: `grep "export" src/lib/cache/manager.ts`
  </verify>
  <done>
- ensureOpenCodeDocsCache() implements 24-hour TTL checking
- Fresh cache (<24hrs) skips download and returns immediately
- Stale cache (>=24hrs) triggers download attempt
- Download failure with stale cache returns graceful degradation (uses old cache)
- Download failure without cache returns error result
- All 7 test scenarios pass
  </done>
</task>

<task type="auto">
  <name>Task 2: CLI Integration</name>
  <files>
    src/cli.ts
  </files>
  <action>
Integrate cache manager into CLI flow between detection and transpilation.

**Modification to src/cli.ts:**

Add cache step after OpenCode detection, before scanning commands:

```typescript
// After OpenCode detection success (around line 47)
console.log('→ Caching OpenCode documentation...');
const cacheResult = await ensureOpenCodeDocsCache();

if (cacheResult.cached) {
  if (cacheResult.stale) {
    console.log('  ⚠ Using stale cache (download failed)');
  } else {
    console.log('  ✓ Documentation cached');
  }
} else {
  console.log('  ⚠ Cache unavailable:', cacheResult.error);
  console.log('  → Continuing without cached docs');
}

// Continue to scanning commands (existing code)
console.log('→ Scanning for /gsd:* commands...');
```

**Import statement to add:**
```typescript
import { ensureOpenCodeDocsCache } from './lib/cache/manager.js';
```

**Key principles:**
- Cache step is non-blocking - failures don't stop installer
- Clear messaging: ✓ for success, ⚠ for degraded states
- Stale cache is acceptable (better than nothing)
- Position after detection (need paths) but before transpilation (future /gsdo will need docs)

**Why this placement:**
- Can't cache before detecting paths (need to know where to write)
- Cache failure shouldn't block transpilation (Phase 1 functionality works independently)
- /gsdo command (Phase 3) will use cached docs, but transpilation (Phase 1) doesn't need them
  </action>
  <verify>
Run `npm run build` - TypeScript compilation succeeds.
Run `npm run dev` - CLI executes cache step and shows appropriate messaging.
Check console output includes "→ Caching OpenCode documentation..." step.
Verify installer continues after cache errors (no process.exit in cache path).
  </verify>
  <done>
- CLI imports ensureOpenCodeDocsCache from cache manager
- Cache step runs after OpenCode detection, before command scanning
- Fresh cache: Shows "✓ Documentation cached"
- Stale cache (degraded): Shows "⚠ Using stale cache (download failed)"
- No cache: Shows "⚠ Cache unavailable: {error}" and continues
- Installer never exits due to cache failures
- TypeScript compiles without errors
  </done>
</task>

</tasks>

<verification>
**Automated checks:**
```bash
npm test  # All tests pass including cache manager tests
npm run build  # TypeScript compilation succeeds
```

**Manual verification - Fresh cache scenario:**
```bash
# First run (no cache)
npm run dev
# Should see: "→ Caching OpenCode documentation..."
#            "✓ Documentation cached"

# Check cache created
ls ~/.gsdo/cache/docs-opencode/
# Should see: README.md, metadata.json

# Second run immediately (fresh cache <24hrs)
npm run dev
# Should see: "→ Caching OpenCode documentation..."
#            "✓ Documentation cached" (no download, used cache)
```

**Manual verification - Stale cache scenario:**
```bash
# Simulate stale cache by editing timestamp
# Edit ~/.gsdo/cache/docs-opencode/metadata.json
# Change downloadedAt to 25 hours ago

npm run dev
# Should see: "→ Caching OpenCode documentation..."
#            "✓ Documentation cached" (triggered download)
```

**Manual verification - Network failure scenario:**
```bash
# Disconnect network or block GitHub
npm run dev
# Should see: "→ Caching OpenCode documentation..."
#            "⚠ Using stale cache (download failed)" (if stale cache exists)
#         OR "⚠ Cache unavailable: Network error" (if no cache exists)
#            "→ Continuing without cached docs"
#            "→ Scanning for /gsd:* commands..." (installer continues)
```
</verification>

<success_criteria>
**Must be TRUE:**
1. Cache manager checks metadata.json age before downloading
2. Fresh cache (<24 hours) skips download and returns immediately
3. Stale cache (>=24 hours) triggers download attempt
4. Download failure with existing cache uses stale cache (graceful degradation)
5. Download failure without cache returns error but doesn't crash
6. CLI shows cache step between detection and scanning
7. CLI continues to transpilation even when cache fails
8. All tests pass (manager tests + existing tests)
9. TypeScript compilation succeeds with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-documentation-cache/02-02-SUMMARY.md`
</output>
