---
phase: 03-transpilation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/transpilation/parser.ts
  - src/lib/transpilation/ir-types.ts
  - src/types/index.ts
autonomous: true

must_haves:
  truths:
    - "CLI can parse GSD files from ~/.claude/ into structured data"
    - "CLI validates GSD file structure before transformation"
    - "CLI reports parse errors with file locations and line numbers"
    - "Parser handles GSD XML/Markdown format without data loss"
  artifacts:
    - path: "src/lib/transpilation/parser.ts"
      provides: "GSD file parsing to AST"
      exports: ["parseGSDFiles", "GSDParseResult"]
      min_lines: 100
    - path: "src/lib/transpilation/ir-types.ts"
      provides: "Intermediate Representation schema"
      exports: ["GSDIntermediate", "GSDAgent", "GSDCommand", "GSDModel"]
      min_lines: 80
    - path: "src/types/index.ts"
      provides: "Parse result types"
      contains: "GSDParseResult"
  key_links:
    - from: "src/lib/transpilation/parser.ts"
      to: "node:fs/promises"
      via: "async file reading"
      pattern: "fs\\.promises\\.readFile"
    - from: "src/lib/transpilation/parser.ts"
      to: "src/lib/transpilation/ir-types.ts"
      via: "IR type imports"
      pattern: "import.*from.*ir-types"
---

<objective>
Build the GSD parser that reads GSD context files and transforms them into an intermediate representation (IR) suitable for transpilation to any target platform.

Purpose: Enable platform-agnostic transformation by decoupling GSD parsing from OpenCode-specific concerns. The IR acts as a bridge between input (GSD) and output (any platform).

Output: Working parser module with comprehensive error handling and validation.
</objective>

<execution_context>
@C:\Users\Terence\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\Terence\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning\PROJECT.md
@.planning\ROADMAP.md
@.planning\STATE.md
@.planning\REQUIREMENTS.md
@.planning\phases\03-transpilation\03-CONTEXT.md
@.planning\phases\03-transpilation\03-RESEARCH.md

# Existing codebase
@src\types\index.ts
@src\lib\logger.ts
@src\lib\paths.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create IR type definitions</name>
  <files>src/lib/transpilation/ir-types.ts</files>
  <action>
Create TypeScript interfaces for the Intermediate Representation (IR) that captures GSD concepts in platform-neutral form.

IR structure (based on research Pattern 2):
- `GSDIntermediate`: Root interface with version, source metadata, agents, commands, models, config, gaps
- `GSDAgent`: Agent definitions (name, model, temperature, systemPrompt, tools)
- `GSDCommand`: Command definitions (name, description, template, variables)
- `GSDModel`: Model definitions (name, provider, config)
- `GSDConfig`: General config (theme, keybindings, permissions, extensible)
- `GSDGaps`: Track unmapped fields and approximations for reporting

Include source metadata:
- `path`: Original GSD directory path
- `hash`: SHA256 content hash (for idempotency)
- `timestamp`: Parse timestamp

Export all interfaces. Use plain interfaces (not classes). Keep types simple and serializable (JSON-compatible).

Why interfaces not classes: IR is data, not behavior. Serialization to JSON for manifest/debugging is straightforward.
  </action>
  <verify>
- `npm run build` compiles without errors
- `src/lib/transpilation/ir-types.ts` exports GSDIntermediate, GSDAgent, GSDCommand, GSDModel, GSDConfig, GSDGaps
- All interfaces are plain data structures (no methods)
  </verify>
  <done>
IR types defined and exported. TypeScript compilation succeeds. Types are JSON-serializable.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement GSD parser</name>
  <files>src/lib/transpilation/parser.ts, src/types/index.ts</files>
  <action>
Create GSD parser that reads files from GSD installation directory and builds intermediate representation.

Parser should:
1. Accept `gsdPath: string` (e.g., `~/.claude/get-shit-done`)
2. Discover GSD files recursively (workflows/, agents/, templates/, etc.)
3. Parse each file type:
   - XML files: agents, commands, workflows (use regex or simple XML parsing - avoid external XML library)
   - Markdown files: templates, documentation (extract frontmatter + content)
   - JSON files: config, mappings (use built-in JSON.parse)
4. Build GSDIntermediate structure:
   - Populate agents[], commands[], models[], config
   - Track unparseable content in gaps.unmappedFields
   - Calculate content hash using node:crypto (SHA256 of all source content sorted by filename)
5. Return `GSDParseResult`:
   ```typescript
   interface GSDParseResult {
     success: boolean;
     ir?: GSDIntermediate;
     errors: Array<{ file: string; line?: number; message: string; stack?: string }>;
     warnings: string[];
   }
   ```

Error handling:
- Fail fast on critical errors (directory not found, unreadable files)
- Continue on parse errors (add to errors[], still return partial IR)
- Use try/catch around file operations, include stack traces
- Provide helpful messages: "Failed to parse ~/.claude/get-shit-done/agents/qa-agent.xml: missing closing tag at line 15"

Use node:fs/promises for async file I/O. Use node:path for cross-platform paths. Use node:crypto for hashing.

Add `GSDParseResult` to src/types/index.ts.

Why simple XML parsing: GSD XML is semantic/lightweight (not complex documents). Regex for tags is sufficient. Avoids xml2js dependency.
  </action>
  <verify>
- `npm run build` compiles without errors
- Parser exports `parseGSDFiles(gsdPath: string): Promise<GSDParseResult>`
- Running parser on test directory (or ~/.claude/ if exists) returns success or detailed errors
- Content hash is deterministic (same source â†’ same hash)
  </verify>
  <done>
Parser implemented with comprehensive error handling. Parse errors include file location and line numbers. Content hashing works for idempotency.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add parser tests</name>
  <files>src/lib/transpilation/parser.test.ts</files>
  <action>
Create Vitest tests for parser.

Test cases:
1. **Happy path**: Mock GSD directory with valid files, verify IR is populated correctly
2. **Missing directory**: Parser returns error with helpful message
3. **Malformed XML**: Parser continues, adds error to errors[], returns partial IR
4. **Empty directory**: Parser returns success with empty agents/commands/models
5. **Idempotency**: Parse same directory twice, verify hashes match
6. **Cross-platform paths**: Verify parser works with both Windows and POSIX paths (use path.join in tests)

Use Vitest mocking (`vi.mock('node:fs/promises')`) to avoid filesystem dependencies.

Why test now: Parser is foundational for entire transpilation phase. Catching parse bugs early prevents downstream failures.
  </action>
  <verify>
- `npm test src/lib/transpilation/parser.test.ts` passes all tests
- Coverage includes error paths (missing dir, malformed XML, empty dir)
- Tests use mocked fs to avoid real filesystem dependencies
  </verify>
  <done>
Parser tests pass. Error handling is verified. Idempotency is confirmed.
  </done>
</task>

</tasks>

<verification>
After all tasks:
- IR types are defined and exported from `src/lib/transpilation/ir-types.ts`
- Parser is implemented in `src/lib/transpilation/parser.ts`
- Parser handles errors gracefully with detailed messages
- Content hashing works for idempotency detection
- Tests confirm parser behavior including error paths
- TypeScript compilation succeeds
- Tests pass
</verification>

<success_criteria>
1. Parser can read GSD files from detected directory and build IR
2. Parse errors include file locations and helpful messages
3. Content hashing is deterministic for idempotency
4. All TypeScript types are defined and exported
5. Tests verify happy path and error handling
</success_criteria>

<output>
After completion, create `.planning/phases/03-transpilation/03-01-SUMMARY.md`
</output>
