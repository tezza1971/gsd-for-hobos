---
phase: 06-exit-logging
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/logger/install-logger.ts
  - src/lib/logger/types.ts
  - src/cli.ts
autonomous: true

must_haves:
  truths:
    - "Installer writes timestamped log entries to ~/.gsdo/install.log"
    - "Log includes per-command transpilation results (success/warning/error)"
    - "Log is readable in plain text editor"
    - "Log uses markdown format with embedded JSON blocks"
    - "Log includes metadata summary (X successful, Y warnings, Z errors)"
  artifacts:
    - path: "src/lib/logger/install-logger.ts"
      provides: "Install log writing with markdown/JSON hybrid format"
      exports: ["writeInstallLog", "LogEntry"]
      min_lines: 80
    - path: "src/lib/logger/types.ts"
      provides: "Shared logging types"
      exports: ["LogLevel", "CommandResult"]
      min_lines: 20
    - path: "~/.gsdo/install.log"
      provides: "Persisted installation logs"
      contains: "# Installation Log"
  key_links:
    - from: "src/cli.ts"
      to: "src/lib/logger/install-logger.ts"
      via: "writeInstallLog call after transpilation"
      pattern: "writeInstallLog.*transpileResult"
    - from: "src/lib/logger/install-logger.ts"
      to: "~/.gsdo/install.log"
      via: "fs.appendFile or fs.writeFile"
      pattern: "appendFile.*install\\.log"
---

<objective>
Create installer logging infrastructure that persists transpilation results to ~/.gsdo/install.log in markdown/JSON hybrid format.

Purpose: Provide visibility into what commands were transpiled, their success/failure status, and detailed error/warning information. Enables troubleshooting and understanding of installation history.

Output: Install logger module and integration into CLI workflow
</objective>

<execution_context>
@C:\Users\Terence\code\gsd-open\.planning\workflows\execute-plan.md
@C:\Users\Terence\code\gsd-open\.planning\templates\summary.md
</execution_context>

<context>
@C:\Users\Terence\code\gsd-open\.planning\PROJECT.md
@C:\Users\Terence\code\gsd-open\.planning\ROADMAP.md
@C:\Users\Terence\code\gsd-open\.planning\STATE.md
@C:\Users\Terence\code\gsd-open\.planning\REQUIREMENTS.md
@C:\Users\Terence\code\gsd-open\.planning\phases\06-exit-logging\06-CONTEXT.md

# Current implementation patterns
@C:\Users\Terence\code\gsd-open\src\cli.ts
@C:\Users\Terence\code\gsd-open\src\lib\paths.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create install logger module with markdown/JSON hybrid format</name>
  <files>
    src/lib/logger/types.ts
    src/lib/logger/install-logger.ts
  </files>
  <action>
Create shared logging types in src/lib/logger/types.ts:
- LogLevel enum: INFO, WARN, ERROR
- CommandResult interface: { name: string, status: 'success' | 'failure', warnings?: string[], error?: string, errorCode?: string }
- LogEntry interface: { timestamp: string, level: LogLevel, summary: string, commands: CommandResult[], metadata: { successful: number, warnings: number, errors: number } }

Create install logger in src/lib/logger/install-logger.ts:
- writeInstallLog(entry: LogEntry): Promise<void> function
- Formats entry as markdown with:
  - H1 header: "# Installation Log"
  - H2 per entry: "## [timestamp] - [summary]"
  - Metadata section: "**Summary:** X successful, Y warnings, Z errors"
  - Per-command details with status icons (✓ success, ⚠ warning, ✗ error)
  - Embedded JSON block with full entry data in fenced code block
  - Horizontal rule separator (---) between entries
- Use fs.appendFile to append entries (don't overwrite existing log)
- Create ~/.gsdo/ directory if not exists
- Use resolveHome from lib/paths.ts for path resolution
- Use error codes pattern: E001 (template extraction failed), E002 (invalid markdown), W001 (missing description), W002 (empty template), W003 (undocumented variables)

Follow existing patterns:
- Import from 'node:fs/promises' (async operations)
- Import from 'node:fs' for existsSync
- Import resolveHome from '../paths.js'
- Use join from 'node:path'
- Graceful error handling with clear error messages
  </action>
  <verify>
npm test -- install-logger.test.ts passes (create test file testing entry formatting and file writing)
  </verify>
  <done>
- src/lib/logger/types.ts exports LogLevel, CommandResult, LogEntry
- src/lib/logger/install-logger.ts exports writeInstallLog function
- Test coverage validates markdown format, JSON embedding, file appending
- Log entries are human-readable and machine-parseable
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate install logging into CLI workflow</name>
  <files>
    src/cli.ts
  </files>
  <action>
Import writeInstallLog from './lib/logger/install-logger.js'.

After transpilation completes (after line ~171 where warnings are logged), create LogEntry:
- timestamp: new Date().toISOString()
- level: transpileResult.failed.length > 0 ? LogLevel.WARN : LogLevel.INFO
- summary: "Transpiled ${successful.length} commands from GSD"
- commands: Map transpileResults to CommandResult array with:
  - name from gsdCommand.name
  - status: 'success' if result.success, 'failure' otherwise
  - warnings: result.warnings array if present
  - error: result.error if present
  - errorCode: Assign based on error message patterns (E001 for template extraction, E002 for invalid markdown, W001 for missing description, etc.)
- metadata: { successful: successful.length, warnings: warnings.length, errors: failed.length }

Call writeInstallLog(logEntry).catch(err => console.warn('Failed to write install log:', err))

Use non-blocking pattern - log write failures shouldn't crash installer.

Keep existing console.log output unchanged (logging is additive, not replacing terminal output).
  </action>
  <verify>
Run npm run dev, check ~/.gsdo/install.log exists and contains formatted entry with timestamp, summary, per-command results, and JSON block.
Run second time, verify new entry appended (not overwritten).
  </verify>
  <done>
- CLI writes install log after each transpilation run
- Log entries contain complete transpilation results
- Log format matches markdown/JSON hybrid specification
- Failed log writes don't crash installer
- Multiple runs append entries (no overwriting)
  </done>
</task>

</tasks>

<verification>
After completing both tasks:

1. Run installer: npm run dev
2. Check log file: cat ~/.gsdo/install.log
3. Verify format:
   - Markdown structure with headers
   - Metadata summary section
   - Per-command details with status icons
   - JSON code block with full data
   - Horizontal rule separator
4. Run installer again
5. Verify second entry appended (not overwritten)
6. Check commands have error codes where appropriate
7. Verify log is readable in plain text editor

All checks pass = LOG-01 and LOG-02 requirements satisfied.
</verification>

<success_criteria>
- Install log written to ~/.gsdo/install.log after each transpilation
- Log uses markdown format with embedded JSON blocks
- Per-command results include success/warning/error status
- Metadata summary shows counts (X successful, Y warnings, Z errors)
- Error codes assigned to warnings and errors
- Entries append (don't overwrite previous entries)
- Log write failures don't crash installer
- Log is human-readable and machine-parseable
</success_criteria>

<output>
After completion, create `.planning/phases/06-exit-logging/06-01-SUMMARY.md`
</output>
